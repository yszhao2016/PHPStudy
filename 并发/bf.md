#并发


程序语言本身的锁

    java    支持
    
    go      支持
        sync包有两个很重要的锁类型
   
             一个叫 Mutex， 利用它可以实现互斥锁。
             一个叫 RWMutex，利用它可以实现读写锁。
    
    php     不支持


乐观锁
    
    可读  更新的只能一个更新
        
        版本  version
        
        cas   比较更新



悲观锁（排它锁）

    加锁后不能读写  for update
    
    如果 where id for update   搜索条件没有索引  会导致锁表！！？？  堵塞！！？？






分布式锁
    
    redis
    
    Zookeeper
    
    
    
 为啥如今php做秒杀都用redis，mysql的悲观锁不一样可以解决超卖问题吗 ？   
    
    其实别说redis、mysql 甚至文件都可以做秒杀
    
    问题 为什么 redis比mysql更适合
    
    第一点 降低mysql的压力
    web应用的架构 是由 n服务器 + mysql 组成的 机器可以无限横向扩容 mysql只有一台 
    所以任何的义务考虑都需要考虑mysql这一点 如果用redis做锁可以较少大部分无效请求落到数据库上
    第二点 性能上
    mysql的索引是b+树 大家应该都清楚 时间复杂度O(Log(n)) 
    那么 如果redis 用set、get、incr的方式 时间复杂度是 O(1) 从这一点 redis > mysql
    第三点 实现上
    mysql的开发需要建表 以后拓展啥的 还要alter table 啥的 大家都知道更新生产环境的表是多么痛苦 
    redis可能就舒服的要死了 具体不细说 自己可以品下 用redis的开发成本和mysql开发成本    
    
    
    
    
    其实不是下面说的两个人分工干活比一个人干会快,而是你在 redis里干的事情和在 
    mysql 干的事情不一样,他们俩的特性也不一样,
    比如说,你在 redis里减库存,只用 incrby -1 然后判断下返回值就好了,
    redis 的特性就导致这个操作不用加锁,就是个原子减,一般情况下,
    十几万的量过来操作这个 减库存,redis 都不会有啥波动.但是你 mysql 要怎么处理,
    先取值出来,在用乐观锁的方式去更新.
    再拿返回值判断是否更新成功了.首先这有几步,再加上查询的消耗,以及失败你是否要重试?其次,
    你问下 DBA 一般数据库会设置的 最大连接数是多少? 一般设置1000,很少能设置到5000.
    另外,就算是你用乐观锁实现了库存这块的逻辑,最终达到的效果也是不一样的,
    如果10000个库存,使用 redis,不做其它限流措施的情况下,可以保证前10000个请求过来都可以减到库存.
    但是你是用 mysql乐观锁,并发的时候,大量更新失败,需要重试,你无法简单的做到 redis 的前10000个请求就可以减到库存,那么你做秒杀,超卖没有,但是公平呢?明明我先请求的,
    就是呗乐观锁导致更新失败,不停的去重试,就算不重试,直接失败了,你让他看到后面的人买到了该怎么想?
    
    mysql的读取写入，大部分是对文件磁盘IO的操作，而redis是对内存的操作，
    高并发场景下，使用redis性能更高
    所以，高并发场景下，用redis
    没有高并发场景下，两种方式都行
    
    
    那你就是对redis不了解了，redis是走内存，MySQL是走磁盘。Redis单机不够，可以主从，主从不够，可以集群。
    
    
    